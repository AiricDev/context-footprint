# CF 需要识别的模式清单

这份清单把 CF 算法需要识别的模式整理成可验证的范围，目的是在不依赖语言语法细节的前提下，用“模式 → 语义信号 → CF 行为”的方式检查实现是否完整。内容基于 `docs/design_pattern.md`，并补充了依赖注入、纯函数、以及大规模状态变更等需求侧关注点。

## 1. 需要显式建模的核心模式

这一部分的模式直接影响 semantic-data 与 code-graph 的设计。

- **依赖注入（Dependency Injection）**
  - 语义信号：依赖通过构造函数/字段注入，并以接口/抽象类型声明。
  - CF 行为：在被注入的接口/抽象类型处形成边界；具体实现不进入调用者上下文。
  - 覆盖：策略/观察者/适配器/外观/模板方法等模式都可以归结为“依赖抽象而非具体实现”。

- **抽象工厂（Abstract Factory）**
  - 语义信号：调用者只感知抽象工厂的接口，具体产品类型由工厂实现隐藏。
  - CF 行为：在抽象工厂接口处形成边界；具体产品族被剪枝。
  - 覆盖：运行时选择具体实现的场景（包括插件式架构）。

- **纯函数（Pure Function）**
  - 语义信号：无外部可变状态读写；仅通过参数/返回值传递数据。
  - CF 行为：上下文只包含函数自身及其直接依赖，不引入隐藏依赖。

- **全局可变状态 / 单例（Large Scale State Change）**
  - 语义信号：共享可变变量存在多个写入者。
  - CF 行为：读者被扩展到所有写入者（`SharedStateWrite`），上下文急剧膨胀。

- **泄漏抽象（Leaky Abstraction）**
  - 语义信号：接口/外观没有足够文档或类型信息，调用者需要理解实现细节。
  - CF 行为：边界失效，遍历进入实现子图。

## 2. 作为算法正确性的测试题

这些模式不需要单独建模，但 CF 分数应自然体现其影响，可作为测试与验收标准。

- **中介者（Mesh → Star）**：依赖拓扑被简化后 CF 显著下降。
- **高内聚 / 低耦合**：依赖稀疏带来更小可达子图。
- **Law of Demeter 违反（Train Wreck）**：链式依赖导致 CF 上升。
- **接口污染 / 胖接口（ISP 违反）**：透明接口引入过度依赖，CF 上升。

## 3. 与实现验证的关系

建议按下面的方式检查算法是否“实现完整”：

- 核心模式具备明确的**语义信号**（接口/抽象类型、文档/类型、共享状态读写）。
- 每个信号都对应清晰的**CF 行为**（停止遍历、剪枝或惩罚扩展）。
- 测试题覆盖 `docs/design_pattern.md` 中已验证的模式，并补足依赖注入、抽象工厂、纯函数、大规模状态变更的场景。

